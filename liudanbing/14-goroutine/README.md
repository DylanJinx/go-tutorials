进程和线程 & 并发和并行 的区别：https://chatgpt.com/share/66eaa33f-be58-8013-8ea1-498d142b6183

## Golang调度器的由来：
https://www.yuque.com/aceld/golang/srxd6d  
![单进程、多进程](./imgs/1.png)
![协程](./imgs/Goroutine.png)
 
## 早期单进程操作系统
![单进程](./imgs/2.png)  
每个进程顺序进行执行，也可以是线程（因为cpu不区分进程和线程）。  

## 多线程/多进程操作系统
cpu有一个轮询调度器，做一个时间片的切分，规定了一个时间宽度，那么一个进程的执行时间就不能超过这个时间片，如果超过，就强制切换进程；等轮训一圈之后，再回到A。从宏观上看，是三个进程一起执行（并发），但实际是cpu在同一时间只执行一个进程。  
![多进程](./imgs/3.png)  
优点：多进程/多线程解决了阻塞问题。  
![多进程缺点](./imgs/4.png)  
但是又有新的问题：切换进程（线程）时，是有切换成本的（cpu从一个进程切换到下一个进程需要保持当前进程的一些状态，中间会有很多上下文的切换，就会有拷贝和复制）  
![多行程缺点](./imgs/5.png)  
同时设计也变得复杂：多线程 伴随 同步竞争（如 锁、竞争资源冲突等）  
![多线程壁垒](./imgs/6.png)  

## 协程
一个线程可以分为用户态和内核态，内核态表示操作系统底层，包括进程开辟、分配资源等；用户态是上层写业务逻辑的、调接口的，能否将这两个空间切分为用户线程和内核线程？如果切换成功，那么就可以让用户线程和内核线程做一个绑定，内核线程就单独整理硬件的东西，用户线程就保证业务层面的效果。cpu的视野只能看到内核，所以cpu本身对这种切分行为是无感的，那么操作系统层面是不需要改任何代码的，只需要在用户线程中改代码就可以了。此时成用户线程称为协程(co-routine)，内核线程称为线程(thread)。  
![协程](./imgs/7.png)  
绑定时，将一个内核线程(thread)通过一个协程调度器（轮询）绑定多个协程(co-routine)，这样cpu还是无感，同时让每个协程都挂载了一个任务，这样用户态依然能够保证一个并发的效果，同时cpu不需要切换了。这种模式称为n:1的协程对应关系。
![n:1](./imgs/8.png)  
这里有一个问题，当一个协程阻塞了，那么会影响下一个协程的调度。

如果改为1:1的协程对应关系，这里没有阻塞的问题了，但是和多线程/多进程一样。  
![1:1](./imgs/9.png)  

M:N的协程对应关系，协程调度器优化的越好（不同的编程语言就需要做它们自己的协程调度器），那么性能越好。  
![m:n](./imgs/10.png)  

## golang对协程的处理
golang在对调度器处理之前，先将协程(co-routine)改为Goroutine，将线程内存改为了几KB，那么就可以灵活调度，可以常切换。

### 调度器
![调度器](./imgs/11.png)  

#### 早期
现在有N个线程，然后有一个协程队列（每有一个任务就放入到协程队列中），现在是m:n的对应关系。
![调度器](./imgs/12.png)  
当M0想要去执行G时，会先去队列中获取锁，然后执行一个Goroutine，剩余没有执行的Goroutine就会往前挪；执行结束后，将会还锁。
![调度器](./imgs/13.png)
缺点：
- 创建、销毁、调度 G 都需要每个 M 获取锁，这会导致激烈的锁竞争。这里的 M 和 G 可能是指系统中的某些资源或操作单元，当多个 M 同时需要获取锁来进行这些操作时，就会产生竞争。
- M 转移 G 会造成延迟和额外的系统负载。这意味着当 M 在转移 G 时，会使系统出现延迟，并且增加系统的负担。
- 系统调用（CPU 在 M 之间的切换）会导致频繁的线程阻塞和取消阻塞操作，增加了系统开销。

